(* Generated by ocaml-tree-sitter. *)
(*
   c_sharp grammar

   entrypoint: compilation_unit
*)

open! Sexplib.Conv
open Tree_sitter_run

type imm_tok_pat_2755817 = Token.t (* pattern "[^{\"\\\\\\n]+" *)
[@@deriving sexp_of]

type modifier = [
    `Abst of Token.t (* "abstract" *)
  | `Async of Token.t (* "async" *)
  | `Const of Token.t (* "const" *)
  | `Extern of Token.t (* "extern" *)
  | `Fixed of Token.t (* "fixed" *)
  | `Inte of Token.t (* "internal" *)
  | `New of Token.t (* "new" *)
  | `Over of Token.t (* "override" *)
  | `Part of Token.t (* "partial" *)
  | `Priv of Token.t (* "private" *)
  | `Prot of Token.t (* "protected" *)
  | `Public of Token.t (* "public" *)
  | `Read of Token.t (* "readonly" *)
  | `Ref of Token.t (* "ref" *)
  | `Sealed of Token.t (* "sealed" *)
  | `Static of Token.t (* "static" *)
  | `Unsafe of Token.t (* "unsafe" *)
  | `Virt of Token.t (* "virtual" *)
  | `Vola of Token.t (* "volatile" *)
]
[@@deriving sexp_of]

type escape_sequence = Token.t
[@@deriving sexp_of]

type pat_52ffbd7 = Token.t (* pattern "[^}\"]+" *)
[@@deriving sexp_of]

type attribute_target_specifier = (
    [
        `Field of Token.t (* "field" *)
      | `Event of Token.t (* "event" *)
      | `Meth of Token.t (* "method" *)
      | `Param of Token.t (* "param" *)
      | `Prop of Token.t (* "property" *)
      | `Ret of Token.t (* "return" *)
      | `Type of Token.t (* "type" *)
    ]
  * Token.t (* ":" *)
)
[@@deriving sexp_of]

type identifier = Token.t
[@@deriving sexp_of]

type pat_6d9db72 = Token.t (* pattern "[^{\"]+" *)
[@@deriving sexp_of]

type parameter_modifier = [
    `Ref of Token.t (* "ref" *)
  | `Out of Token.t (* "out" *)
  | `This of Token.t (* "this" *)
  | `In of Token.t (* "in" *)
]
[@@deriving sexp_of]

type real_literal = Token.t
[@@deriving sexp_of]

type integer_literal = Token.t
[@@deriving sexp_of]

type verbatim_string_literal = Token.t
[@@deriving sexp_of]

type tok_pat_f6e1de8 = Token.t
[@@deriving sexp_of]

type assignment_operator = [
    `EQ of Token.t (* "=" *)
  | `PLUSEQ of Token.t (* "+=" *)
  | `DASHEQ of Token.t (* "-=" *)
  | `STAREQ of Token.t (* "*=" *)
  | `SLASHEQ of Token.t (* "/=" *)
  | `PERCEQ of Token.t (* "%=" *)
  | `AMPEQ of Token.t (* "&=" *)
  | `HATEQ of Token.t (* "^=" *)
  | `BAREQ of Token.t (* "|=" *)
  | `LTLTEQ of Token.t (* "<<=" *)
  | `GTGTEQ of Token.t (* ">>=" *)
  | `QMARKQMARKEQ of Token.t (* "??=" *)
]
[@@deriving sexp_of]

type reserved_identifier = [ `From of Token.t (* "from" *) ]
[@@deriving sexp_of]

type default_switch_label = (Token.t (* "default" *) * Token.t (* ":" *))
[@@deriving sexp_of]

type preproc_directive_end = Token.t
[@@deriving sexp_of]

type overloadable_operator = [
    `BANG of Token.t (* "!" *)
  | `TILDE of Token.t (* "~" *)
  | `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
  | `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
  | `PLUS of Token.t (* "+" *)
  | `DASH of Token.t (* "-" *)
  | `STAR of Token.t (* "*" *)
  | `SLASH of Token.t (* "/" *)
  | `PERC of Token.t (* "%" *)
  | `HAT of Token.t (* "^" *)
  | `BAR of Token.t (* "|" *)
  | `AMP of Token.t (* "&" *)
  | `LTLT of Token.t (* "<<" *)
  | `GTGT of Token.t (* ">>" *)
  | `EQEQ of Token.t (* "==" *)
  | `BANGEQ of Token.t (* "!=" *)
  | `GT of Token.t (* ">" *)
  | `LT of Token.t (* "<" *)
  | `GTEQ of Token.t (* ">=" *)
  | `LTEQ of Token.t (* "<=" *)
]
[@@deriving sexp_of]

type imm_tok_pat_5a6fa79 = Token.t (* pattern "[^\"\\\\\\n]+" *)
[@@deriving sexp_of]

type imm_tok_pat_684220d = Token.t (* pattern "[^'\\\\]" *)
[@@deriving sexp_of]

type boolean_literal = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]
[@@deriving sexp_of]

type predefined_type = Token.t
[@@deriving sexp_of]

type preprocessor_directive = Token.t (* pattern #[a-z]\w* *)
[@@deriving sexp_of]

type interpolated_string_text = [
    `LCURLLCURL of Token.t (* "{{" *)
  | `Imm_tok_pat_2755817 of imm_tok_pat_2755817 (*tok*)
  | `Esc_seq of escape_sequence (*tok*)
]
[@@deriving sexp_of]

type interpolation_format_clause = (Token.t (* ":" *) * pat_52ffbd7 (*tok*))
[@@deriving sexp_of]

type join_into_clause = (Token.t (* "into" *) * identifier (*tok*))
[@@deriving sexp_of]

type interpolated_verbatim_string_text = [
    `Pat_6d9db72 of pat_6d9db72 (*tok*)
  | `DQUOTDQUOT of Token.t (* "\"\"" *)
]
[@@deriving sexp_of]

type variable_designation = [
    `Disc of Token.t (* "_" *)
  | `Paren_var_desi of (
        Token.t (* "(" *)
      * (
            variable_designation
          * (Token.t (* "," *) * variable_designation)
              list (* zero or more *)
        )
          option
      * Token.t (* ")" *)
    )
  | `Id of identifier (*tok*)
]
[@@deriving sexp_of]

type anon_choice_id_43fe74f = [
    `Id of identifier (*tok*)
  | `Disc of Token.t (* "_" *)
]
[@@deriving sexp_of]

type identifier_or_global = [
    `Global of Token.t (* "global" *)
  | `Id of identifier (*tok*)
]
[@@deriving sexp_of]

type tuple_pattern = (
    Token.t (* "(" *)
  * anon_choice_id_43fe74f
  * (Token.t (* "," *) * anon_choice_id_43fe74f) list (* zero or more *)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type name_equals = (identifier_or_global * Token.t (* "=" *))
[@@deriving sexp_of]

type name_colon = (identifier_or_global * Token.t (* ":" *))
[@@deriving sexp_of]

type literal = [
    `Null_lit of Token.t (* "null" *)
  | `Bool_lit of boolean_literal
  | `Char_lit of (
        Token.t (* "'" *)
      * [
            `Imm_tok_pat_684220d of imm_tok_pat_684220d (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
      * Token.t (* "'" *)
    )
  | `Real_lit of real_literal (*tok*)
  | `Int_lit of integer_literal (*tok*)
  | `Str_lit of (
        Token.t (* "\"" *)
      * [
            `Imm_tok_pat_5a6fa79 of imm_tok_pat_5a6fa79 (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `Verb_str_lit of verbatim_string_literal (*tok*)
]
[@@deriving sexp_of]

type anon_choice_param_ce11a32 = [
    `Param of parameter
  | `Param_array of (
        attribute_list list (* zero or more *)
      * Token.t (* "params" *)
      * array_type
      * identifier (*tok*)
    )
]

and anon_opt_cst_pat_rep_interp_alig_clause_080fdff =
  (constant_pattern * interpolation_alignment_clause list (* zero or more *))
    option

and anonymous_object_member_declarator = [
    `Name_equals_exp of (name_equals * constant_pattern)
  | `Exp of constant_pattern
]

and argument = (
    name_colon option
  * [
        `Ref of Token.t (* "ref" *)
      | `Out of Token.t (* "out" *)
      | `In of Token.t (* "in" *)
    ]
      option
  * [ `Exp of constant_pattern | `Decl_exp of declaration_expression ]
)

and argument_list = (
    Token.t (* "(" *)
  * (argument * (Token.t (* "," *) * argument) list (* zero or more *))
      option
  * Token.t (* ")" *)
)

and array_rank_specifier = (
    Token.t (* "[" *)
  * (
        constant_pattern option
      * (Token.t (* "," *) * constant_pattern option) list (* zero or more *)
    )
      option
  * Token.t (* "]" *)
)

and array_type = (type_constraint * array_rank_specifier)

and arrow_expression_clause = (Token.t (* "=>" *) * constant_pattern)

and attribute = (name * attribute_argument_list option)

and attribute_argument = (
    [ `Name_equals of name_equals | `Name_colon of name_colon ] option
  * constant_pattern
)

and attribute_argument_list = (
    Token.t (* "(" *)
  * (
        attribute_argument
      * (Token.t (* "," *) * attribute_argument) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and attribute_list = (
    Token.t (* "[" *)
  * attribute_target_specifier option
  * attribute
  * (Token.t (* "," *) * attribute) list (* zero or more *)
  * Token.t (* "]" *)
)

and binary_expression = [
    `Exp_AMPAMP_exp of (
        constant_pattern * Token.t (* "&&" *) * constant_pattern
    )
  | `Exp_BARBAR_exp of (
        constant_pattern * Token.t (* "||" *) * constant_pattern
    )
  | `Exp_GTGT_exp of (
        constant_pattern * Token.t (* ">>" *) * constant_pattern
    )
  | `Exp_LTLT_exp of (
        constant_pattern * Token.t (* "<<" *) * constant_pattern
    )
  | `Exp_AMP_exp of (constant_pattern * Token.t (* "&" *) * constant_pattern)
  | `Exp_HAT_exp of (constant_pattern * Token.t (* "^" *) * constant_pattern)
  | `Exp_BAR_exp of (constant_pattern * Token.t (* "|" *) * constant_pattern)
  | `Exp_PLUS_exp of (
        constant_pattern * Token.t (* "+" *) * constant_pattern
    )
  | `Exp_DASH_exp of (
        constant_pattern * Token.t (* "-" *) * constant_pattern
    )
  | `Exp_STAR_exp of (
        constant_pattern * Token.t (* "*" *) * constant_pattern
    )
  | `Exp_SLASH_exp of (
        constant_pattern * Token.t (* "/" *) * constant_pattern
    )
  | `Exp_PERC_exp of (
        constant_pattern * Token.t (* "%" *) * constant_pattern
    )
  | `Exp_LT_exp of (constant_pattern * Token.t (* "<" *) * constant_pattern)
  | `Exp_LTEQ_exp of (
        constant_pattern * Token.t (* "<=" *) * constant_pattern
    )
  | `Exp_EQEQ_exp of (
        constant_pattern * Token.t (* "==" *) * constant_pattern
    )
  | `Exp_BANGEQ_exp of (
        constant_pattern * Token.t (* "!=" *) * constant_pattern
    )
  | `Exp_GTEQ_exp of (
        constant_pattern * Token.t (* ">=" *) * constant_pattern
    )
  | `Exp_GT_exp of (constant_pattern * Token.t (* ">" *) * constant_pattern)
  | `Exp_QMARKQMARK_exp of (
        constant_pattern * Token.t (* "??" *) * constant_pattern
    )
  | `Exp_choice_is_type of (
        constant_pattern
      * [ `Is of Token.t (* "is" *) | `As of Token.t (* "as" *) ]
      * type_constraint
    )
]

and block = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)

and bracketed_argument_list = (
    Token.t (* "[" *)
  * argument
  * (Token.t (* "," *) * argument) list (* zero or more *)
  * Token.t (* "]" *)
)

and case_pattern_switch_label = (
    Token.t (* "case" *)
  * pattern
  * when_clause option
  * Token.t (* ":" *)
)

and case_switch_label = (
    Token.t (* "case" *) * constant_pattern * Token.t (* ":" *)
)

and catch_clause = (
    Token.t (* "catch" *)
  * catch_declaration option
  * catch_filter_clause option
  * block
)

and catch_declaration = (
    Token.t (* "(" *)
  * type_constraint
  * identifier (*tok*) option
  * Token.t (* ")" *)
)

and catch_filter_clause = (
    Token.t (* "when" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* ")" *)
)

and checked_expression = [
    `Chec_LPAR_exp_RPAR of (
        Token.t (* "checked" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *)
    )
  | `Unch_LPAR_exp_RPAR of (
        Token.t (* "unchecked" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *)
    )
]

and constant_pattern = expression

and declaration_expression = (type_constraint * identifier (*tok*))

and element_binding_expression = bracketed_argument_list

and equals_value_clause = (Token.t (* "=" *) * constant_pattern)

and expression = [
    `Anon_meth_exp of (
        Token.t (* "async" *) option
      * Token.t (* "delegate" *)
      * parameter_list option
      * block
    )
  | `Anon_obj_crea_exp of (
        Token.t (* "new" *)
      * Token.t (* "{" *)
      * (
            anonymous_object_member_declarator
          * (Token.t (* "," *) * anonymous_object_member_declarator)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Array_crea_exp of (
        Token.t (* "new" *)
      * array_type
      * initializer_expression option
    )
  | `Assign_exp of (
        constant_pattern * assignment_operator * constant_pattern
    )
  | `Await_exp of (Token.t (* "await" *) * constant_pattern)
  | `Base_exp of Token.t (* "base" *)
  | `Bin_exp of binary_expression
  | `Cast_exp of (
        Token.t (* "(" *) * type_constraint * Token.t (* ")" *)
      * constant_pattern
    )
  | `Chec_exp of checked_expression
  | `Cond_access_exp of (
        constant_pattern * Token.t (* "?" *) * constant_pattern
    )
  | `Cond_exp of (
        constant_pattern * Token.t (* "?" *) * constant_pattern
      * Token.t (* ":" *) * constant_pattern
    )
  | `Defa_exp of (
        Token.t (* "default" *)
      * (Token.t (* "(" *) * type_constraint * Token.t (* ")" *)) option
    )
  | `Elem_access_exp of (constant_pattern * element_binding_expression)
  | `Elem_bind_exp of element_binding_expression
  | `Impl_array_crea_exp of (
        Token.t (* "new" *)
      * Token.t (* "[" *)
      * Token.t (* "," *) list (* zero or more *)
      * Token.t (* "]" *)
      * initializer_expression
    )
  | `Impl_stack_alloc_array_crea_exp of (
        Token.t (* "stackalloc" *) * Token.t (* "[" *) * Token.t (* "]" *)
      * initializer_expression
    )
  | `Init_exp of initializer_expression
  | `Inte_str_exp of interpolated_string_expression
  | `Invo_exp of (constant_pattern * argument_list)
  | `Is_pat_exp of (constant_pattern * Token.t (* "is" *) * pattern)
  | `Lambda_exp of (
        Token.t (* "async" *) option
      * [ `Param_list of parameter_list | `Id of identifier (*tok*) ]
      * Token.t (* "=>" *)
      * [ `Blk of block | `Exp of constant_pattern ]
    )
  | `Make_ref_exp of (
        Token.t (* "__makeref" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *)
    )
  | `Member_access_exp of (
        [
            `Exp of constant_pattern
          | `Type of type_constraint
          | `Name of name
        ]
      * [ `DOT of Token.t (* "." *) | `DASHGT of Token.t (* "->" *) ]
      * simple_name
    )
  | `Member_bind_exp of (Token.t (* "." *) * simple_name)
  | `Obj_crea_exp of (
        Token.t (* "new" *)
      * type_constraint
      * argument_list option
      * initializer_expression option
    )
  | `Paren_exp of (Token.t (* "(" *) * constant_pattern * Token.t (* ")" *))
  | `Post_un_exp of postfix_unary_expression
  | `Prefix_un_exp of prefix_unary_expression
  | `Query_exp of (from_clause * query_body)
  | `Range_exp of (
        constant_pattern option
      * Token.t (* ".." *)
      * constant_pattern option
    )
  | `Ref_exp of (Token.t (* "ref" *) * constant_pattern)
  | `Ref_type_exp of (
        Token.t (* "__reftype" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *)
    )
  | `Ref_value_exp of (
        Token.t (* "__refvalue" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* "," *) * type_constraint * Token.t (* ")" *)
    )
  | `Size_of_exp of (
        Token.t (* "sizeof" *) * Token.t (* "(" *) * type_constraint
      * Token.t (* ")" *)
    )
  | `Stack_alloc_array_crea_exp of (
        Token.t (* "stackalloc" *)
      * array_type
      * initializer_expression option
    )
  | `Switch_exp of (
        constant_pattern
      * Token.t (* "switch" *)
      * Token.t (* "{" *)
      * (
            switch_expression_arm
          * (Token.t (* "," *) * switch_expression_arm)
              list (* zero or more *)
        )
          option
      * Token.t (* "}" *)
    )
  | `This_exp of Token.t (* "this" *)
  | `Throw_exp of (Token.t (* "throw" *) * constant_pattern)
  | `Tuple_exp of (
        Token.t (* "(" *)
      * argument
      * (Token.t (* "," *) * argument) list (* one or more *)
      * Token.t (* ")" *)
    )
  | `Type_of_exp of (
        Token.t (* "typeof" *) * Token.t (* "(" *) * type_constraint
      * Token.t (* ")" *)
    )
  | `Simple_name of simple_name
  | `Rese_id of reserved_identifier
  | `Lit of literal
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips of (
        Token.t (* "<..." *) * constant_pattern * Token.t (* "...>" *)
    )
]

and expression_statement = [
    `Exp_SEMI of (constant_pattern * Token.t (* ";" *))
  | `Ellips_SEMI of (Token.t (* "..." *) * Token.t (* ";" *))
  | `Ellips of Token.t (* "..." *)
]

and finally_clause = (Token.t (* "finally" *) * block)

and formal_parameter_list = (
    anon_choice_param_ce11a32
  * (Token.t (* "," *) * anon_choice_param_ce11a32) list (* zero or more *)
)

and from_clause = (
    Token.t (* "from" *)
  * type_constraint option
  * identifier (*tok*)
  * Token.t (* "in" *)
  * constant_pattern
)

and function_body = [
    `Blk of block
  | `Arrow_exp_clause_SEMI of (arrow_expression_clause * Token.t (* ";" *))
  | `SEMI of Token.t (* ";" *)
]

and initializer_expression = (
    Token.t (* "{" *)
  * anon_opt_cst_pat_rep_interp_alig_clause_080fdff
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and interpolated_string_content = [
    `Inte_str_text of interpolated_string_text
  | `Interp of interpolation
]

and interpolated_string_expression = [
    `DOLLARDQUOT_rep_inte_str_content_DQUOT of (
        Token.t (* "$\"" *)
      * interpolated_string_content list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `DOLLARATDQUOT_rep_inte_verb_str_content_DQUOT of (
        Token.t (* "$@\"" *)
      * interpolated_verbatim_string_content list (* zero or more *)
      * Token.t (* "\"" *)
    )
]

and interpolated_verbatim_string_content = [
    `Inte_verb_str_text of interpolated_verbatim_string_text
  | `Interp of interpolation
]

and interpolation = (
    Token.t (* "{" *)
  * constant_pattern
  * interpolation_alignment_clause option
  * interpolation_format_clause option
  * Token.t (* "}" *)
)

and interpolation_alignment_clause = (Token.t (* "," *) * constant_pattern)

and name = [
    `Alias_qual_name of (
        identifier_or_global * Token.t (* "::" *) * simple_name
    )
  | `Qual_name of (name * Token.t (* "." *) * simple_name)
  | `Simple_name of simple_name
]

and nullable_type = [ `Type_QMARK of (type_constraint * Token.t (* "?" *)) ]

and ordering = (
    constant_pattern
  * [
        `Asce of Token.t (* "ascending" *)
      | `Desc of Token.t (* "descending" *)
    ]
      option
)

and parameter = (
    attribute_list list (* zero or more *)
  * parameter_modifier option
  * type_constraint option
  * identifier (*tok*)
  * equals_value_clause option
)

and parameter_list = (
    Token.t (* "(" *)
  * formal_parameter_list option
  * Token.t (* ")" *)
)

and pattern = [
    `Cst_pat of constant_pattern
  | `Decl_pat of (type_constraint * variable_designation)
  | `Disc of Token.t (* "_" *)
  | `Var_pat of (Token.t (* "var" *) * variable_designation)
]

and postfix_unary_expression = [
    `Exp_PLUSPLUS of (constant_pattern * Token.t (* "++" *))
  | `Exp_DASHDASH of (constant_pattern * Token.t (* "--" *))
  | `Exp_BANG of (constant_pattern * Token.t (* "!" *))
]

and prefix_unary_expression = [
    `BANG_exp of (Token.t (* "!" *) * constant_pattern)
  | `AMP_exp of (Token.t (* "&" *) * constant_pattern)
  | `STAR_exp of (Token.t (* "*" *) * constant_pattern)
  | `PLUS_exp of (Token.t (* "+" *) * constant_pattern)
  | `PLUSPLUS_exp of (Token.t (* "++" *) * constant_pattern)
  | `DASH_exp of (Token.t (* "-" *) * constant_pattern)
  | `DASHDASH_exp of (Token.t (* "--" *) * constant_pattern)
  | `HAT_exp of (Token.t (* "^" *) * constant_pattern)
  | `TILDE_exp of (Token.t (* "~" *) * constant_pattern)
]

and query_body = [
  `Rectype of (
      query_clause list (* zero or more *)
    * select_or_group_clause
    * query_continuation option
  )
]

and query_clause = [
    `From_clause of from_clause
  | `Join_clause of (
        Token.t (* "join" *)
      * type_constraint option
      * identifier (*tok*)
      * Token.t (* "in" *)
      * constant_pattern
      * Token.t (* "on" *)
      * constant_pattern
      * Token.t (* "equals" *)
      * constant_pattern
      * join_into_clause option
    )
  | `Let_clause of (
        Token.t (* "let" *) * identifier (*tok*) * Token.t (* "=" *)
      * constant_pattern
    )
  | `Order_by_clause of (
        Token.t (* "orderby" *)
      * ordering
      * (Token.t (* "," *) * ordering) list (* zero or more *)
    )
  | `Where_clause of (Token.t (* "where" *) * constant_pattern)
]

and query_continuation = [
  `Rectype of (Token.t (* "into" *) * identifier (*tok*) * query_body)
]

and return_type = [
    `Type of type_constraint
  | `Void_kw of Token.t (* "void" *)
]

and select_or_group_clause = [
    `Group_clause of (
        Token.t (* "group" *) * constant_pattern * Token.t (* "by" *)
      * constant_pattern
    )
  | `Select_clause of (Token.t (* "select" *) * constant_pattern)
]

and simple_name = [
    `Gene_name of (identifier (*tok*) * type_argument_list)
  | `Choice_global of identifier_or_global
]

and statement = [
    `Blk of block
  | `Brk_stmt of (Token.t (* "break" *) * Token.t (* ";" *))
  | `Chec_stmt of (
        [
            `Chec of Token.t (* "checked" *)
          | `Unch of Token.t (* "unchecked" *)
        ]
      * block
    )
  | `Cont_stmt of (Token.t (* "continue" *) * Token.t (* ";" *))
  | `Do_stmt of (
        Token.t (* "do" *) * statement * Token.t (* "while" *)
      * Token.t (* "(" *) * constant_pattern * Token.t (* ")" *)
      * Token.t (* ";" *)
    )
  | `Empty_stmt of Token.t (* ";" *)
  | `Exp_stmt of expression_statement
  | `Fixed_stmt of (
        Token.t (* "fixed" *) * Token.t (* "(" *) * variable_declaration
      * Token.t (* ")" *) * statement
    )
  | `For_each_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "foreach" *)
      * Token.t (* "(" *)
      * [ `Type_id of declaration_expression | `Exp of constant_pattern ]
      * Token.t (* "in" *)
      * constant_pattern
      * Token.t (* ")" *)
      * statement
    )
  | `For_stmt of (
        Token.t (* "for" *)
      * Token.t (* "(" *)
      * [
            `Var_decl of variable_declaration
          | `Exp_rep_COMMA_exp of (
                constant_pattern
              * interpolation_alignment_clause list (* zero or more *)
            )
        ]
          option
      * Token.t (* ";" *)
      * constant_pattern option
      * Token.t (* ";" *)
      * anon_opt_cst_pat_rep_interp_alig_clause_080fdff
      * Token.t (* ")" *)
      * statement
    )
  | `Goto_stmt of (
        Token.t (* "goto" *)
      * [
            `Id of identifier (*tok*)
          | `Case_exp of (Token.t (* "case" *) * constant_pattern)
          | `Defa of Token.t (* "default" *)
        ]
      * Token.t (* ";" *)
    )
  | `If_stmt of (
        Token.t (* "if" *)
      * Token.t (* "(" *)
      * constant_pattern
      * Token.t (* ")" *)
      * statement
      * (Token.t (* "else" *) * statement) option
    )
  | `Labe_stmt of (identifier (*tok*) * Token.t (* ":" *) * statement)
  | `Local_decl_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "using" *) option
      * modifier list (* zero or more *)
      * variable_declaration
      * Token.t (* ";" *)
    )
  | `Local_func_stmt of (
        modifier list (* zero or more *)
      * return_type
      * identifier (*tok*)
      * type_parameter_list option
      * parameter_list
      * type_parameter_constraints_clause list (* zero or more *)
      * function_body
    )
  | `Lock_stmt of (
        Token.t (* "lock" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *) * statement
    )
  | `Ret_stmt of (
        Token.t (* "return" *)
      * constant_pattern option
      * Token.t (* ";" *)
    )
  | `Switch_stmt of (
        Token.t (* "switch" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *) * switch_body
    )
  | `Throw_stmt of (
        Token.t (* "throw" *)
      * constant_pattern option
      * Token.t (* ";" *)
    )
  | `Try_stmt of (
        Token.t (* "try" *)
      * block
      * catch_clause list (* zero or more *)
      * finally_clause option
    )
  | `Unsafe_stmt of (Token.t (* "unsafe" *) * block)
  | `Using_stmt of (
        Token.t (* "await" *) option
      * Token.t (* "using" *)
      * Token.t (* "(" *)
      * [ `Var_decl of variable_declaration | `Exp of constant_pattern ]
      * Token.t (* ")" *)
      * statement
    )
  | `While_stmt of (
        Token.t (* "while" *) * Token.t (* "(" *) * constant_pattern
      * Token.t (* ")" *) * statement
    )
  | `Yield_stmt of (
        Token.t (* "yield" *)
      * [
            `Ret_exp of (Token.t (* "return" *) * constant_pattern)
          | `Brk of Token.t (* "break" *)
        ]
      * Token.t (* ";" *)
    )
]

and switch_body = (
    Token.t (* "{" *)
  * switch_section list (* zero or more *)
  * Token.t (* "}" *)
)

and switch_expression_arm = (
    pattern
  * when_clause option
  * Token.t (* "=>" *)
  * constant_pattern
)

and switch_section = (
    [
        `Case_switch_label of case_switch_label
      | `Case_pat_switch_label of case_pattern_switch_label
      | `Defa_switch_label of default_switch_label
    ]
      list (* one or more *)
  * statement list (* one or more *)
)

and tuple_element = (type_constraint * identifier (*tok*) option)

and type_ = [
    `Impl_type of Token.t (* "var" *)
  | `Array_type of array_type
  | `Name of name
  | `Null_type of nullable_type
  | `Poin_type of (type_constraint * Token.t (* "*" *))
  | `Pred_type of predefined_type (*tok*)
  | `Tuple_type of (
        Token.t (* "(" *)
      * tuple_element
      * (Token.t (* "," *) * tuple_element) list (* one or more *)
      * Token.t (* ")" *)
    )
]

and type_argument_list = (
    Token.t (* "<" *)
  * [
        `Rep_COMMA of Token.t (* "," *) list (* zero or more *)
      | `Type_rep_COMMA_type of (
            type_constraint
          * (Token.t (* "," *) * type_constraint) list (* zero or more *)
        )
    ]
  * Token.t (* ">" *)
)

and type_constraint = type_

and type_parameter = (
    attribute_list option
  * [ `In of Token.t (* "in" *) | `Out of Token.t (* "out" *) ] option
  * identifier (*tok*)
)

and type_parameter_constraint = [
    `Class of Token.t (* "class" *)
  | `Struct of Token.t (* "struct" *)
  | `Unma of Token.t (* "unmanaged" *)
  | `Cons_cons of (
        Token.t (* "new" *) * Token.t (* "(" *) * Token.t (* ")" *)
    )
  | `Type_cons of type_constraint
]

and type_parameter_constraints_clause = (
    Token.t (* "where" *)
  * identifier_or_global
  * Token.t (* ":" *)
  * type_parameter_constraint
  * (Token.t (* "," *) * type_parameter_constraint) list (* zero or more *)
)

and type_parameter_list = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* ">" *)
)

and variable_declaration = (
    type_constraint
  * variable_declarator
  * (Token.t (* "," *) * variable_declarator) list (* zero or more *)
)

and variable_declarator = (
    [ `Id of identifier (*tok*) | `Tuple_pat of tuple_pattern ]
  * element_binding_expression option
  * equals_value_clause option
)

and when_clause = (Token.t (* "when" *) * constant_pattern)
[@@deriving sexp_of]

type constructor_initializer = (
    Token.t (* ":" *)
  * [ `Base of Token.t (* "base" *) | `This of Token.t (* "this" *) ]
  * argument_list
)
[@@deriving sexp_of]

type base_list = (
    Token.t (* ":" *)
  * type_constraint
  * (Token.t (* "," *) * type_constraint) list (* zero or more *)
)
[@@deriving sexp_of]

type subpattern = (name_colon option * pattern)
[@@deriving sexp_of]

type enum_member_declaration = (
    attribute_list list (* zero or more *)
  * identifier (*tok*)
  * equals_value_clause option
)
[@@deriving sexp_of]

type explicit_interface_specifier = (name * Token.t (* "." *))
[@@deriving sexp_of]

type bracketed_parameter_list = (
    Token.t (* "[" *)
  * parameter
  * (Token.t (* "," *) * parameter) list (* zero or more *)
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type accessor_declaration = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * [
        `Get of Token.t (* "get" *)
      | `Set of Token.t (* "set" *)
      | `Add of Token.t (* "add" *)
      | `Remove of Token.t (* "remove" *)
      | `Id of identifier (*tok*)
    ]
  * function_body
)
[@@deriving sexp_of]

type anon_subp_rep_COMMA_subp_300d2c5 = (
    subpattern
  * (Token.t (* "," *) * subpattern) list (* zero or more *)
)
[@@deriving sexp_of]

type enum_member_declaration_list = (
    Token.t (* "{" *)
  * (
        enum_member_declaration
      * (Token.t (* "," *) * enum_member_declaration) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type accessor_list = (
    Token.t (* "{" *)
  * accessor_declaration list (* zero or more *)
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type positional_pattern_clause = (
    Token.t (* "(" *)
  * anon_subp_rep_COMMA_subp_300d2c5 option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type property_pattern_clause = (
    Token.t (* "{" *)
  * anon_subp_rep_COMMA_subp_300d2c5 option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type declaration = [
    `Global_attr_list of (
        Token.t (* "[" *)
      * [
            `Asse of Token.t (* "assembly" *)
          | `Module of Token.t (* "module" *)
        ]
      * Token.t (* ":" *)
      * (attribute * (Token.t (* "," *) * attribute) list (* zero or more *))
          option
      * Token.t (* "]" *)
    )
  | `Class_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "class" *)
      * identifier (*tok*)
      * type_parameter_list option
      * base_list option
      * type_parameter_constraints_clause list (* zero or more *)
      * declaration_list
      * Token.t (* ";" *) option
    )
  | `Cons_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * identifier (*tok*)
      * parameter_list
      * constructor_initializer option
      * function_body
    )
  | `Conv_op_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * [
            `Impl of Token.t (* "implicit" *)
          | `Expl of Token.t (* "explicit" *)
        ]
      * Token.t (* "operator" *)
      * type_constraint
      * parameter_list
      * function_body
    )
  | `Dele_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "delegate" *)
      * return_type
      * identifier (*tok*)
      * type_parameter_list option
      * parameter_list
      * type_parameter_constraints_clause list (* zero or more *)
      * Token.t (* ";" *)
    )
  | `Dest_decl of (
        attribute_list list (* zero or more *)
      * Token.t (* "extern" *) option
      * Token.t (* "~" *)
      * identifier (*tok*)
      * parameter_list
      * function_body
    )
  | `Enum_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "enum" *)
      * identifier (*tok*)
      * base_list option
      * enum_member_declaration_list
      * Token.t (* ";" *) option
    )
  | `Event_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "event" *)
      * type_constraint
      * explicit_interface_specifier option
      * identifier (*tok*)
      * [ `Acce_list of accessor_list | `SEMI of Token.t (* ";" *) ]
    )
  | `Extern_alias_dire of (
        Token.t (* "extern" *) * Token.t (* "alias" *) * identifier (*tok*)
      * Token.t (* ";" *)
    )
  | `Event_field_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "event" *)
      * variable_declaration
      * Token.t (* ";" *)
    )
  | `Field_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * variable_declaration
      * Token.t (* ";" *)
    )
  | `Inde_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_constraint
      * explicit_interface_specifier option
      * Token.t (* "this" *)
      * bracketed_parameter_list
      * [
            `Acce_list of accessor_list
          | `Arrow_exp_clause_SEMI of (
                arrow_expression_clause * Token.t (* ";" *)
            )
        ]
    )
  | `Inte_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "interface" *)
      * identifier (*tok*)
      * type_parameter_list option
      * base_list option
      * type_parameter_constraints_clause list (* zero or more *)
      * declaration_list
      * Token.t (* ";" *) option
    )
  | `Meth_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * return_type
      * explicit_interface_specifier option
      * identifier (*tok*)
      * type_parameter_list option
      * parameter_list
      * type_parameter_constraints_clause list (* zero or more *)
      * function_body
    )
  | `Name_decl of (
        Token.t (* "namespace" *)
      * name
      * declaration_list
      * Token.t (* ";" *) option
    )
  | `Op_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_constraint
      * Token.t (* "operator" *)
      * overloadable_operator
      * parameter_list
      * function_body
    )
  | `Prop_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * type_constraint
      * explicit_interface_specifier option
      * identifier (*tok*)
      * [
            `Acce_list_opt_EQ_exp_SEMI of (
                accessor_list
              * (Token.t (* "=" *) * constant_pattern * Token.t (* ";" *))
                  option
            )
          | `Arrow_exp_clause_SEMI of (
                arrow_expression_clause * Token.t (* ";" *)
            )
        ]
    )
  | `Struct_decl of (
        attribute_list list (* zero or more *)
      * modifier list (* zero or more *)
      * Token.t (* "struct" *)
      * identifier (*tok*)
      * type_parameter_list option
      * base_list option
      * type_parameter_constraints_clause list (* zero or more *)
      * declaration_list
      * Token.t (* ";" *) option
    )
  | `Using_dire of (
        Token.t (* "using" *)
      * [ `Static of Token.t (* "static" *) | `Name_equals of name_equals ]
          option
      * name
      * Token.t (* ";" *)
    )
]

and declaration_list = (
    Token.t (* "{" *)
  * declaration list (* zero or more *)
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type compilation_unit = [
    `Rep_decl of declaration list (* zero or more *)
  | `Semg_exp of (Token.t (* "__SEMGREP_EXPRESSION" *) * constant_pattern)
]
[@@deriving sexp_of]

type continue_statement (* inlined *) = (
    Token.t (* "continue" *) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type ellipsis (* inlined *) = Token.t (* "..." *)
[@@deriving sexp_of]

type null_literal (* inlined *) = Token.t (* "null" *)
[@@deriving sexp_of]

type comment (* inlined *) = Token.t
[@@deriving sexp_of]

type void_keyword (* inlined *) = Token.t (* "void" *)
[@@deriving sexp_of]

type constructor_constraint (* inlined *) = (
    Token.t (* "new" *) * Token.t (* "(" *) * Token.t (* ")" *)
)
[@@deriving sexp_of]

type discard (* inlined *) = Token.t (* "_" *)
[@@deriving sexp_of]

type global (* inlined *) = Token.t (* "global" *)
[@@deriving sexp_of]

type this_expression (* inlined *) = Token.t (* "this" *)
[@@deriving sexp_of]

type empty_statement (* inlined *) = Token.t (* ";" *)
[@@deriving sexp_of]

type break_statement (* inlined *) = (
    Token.t (* "break" *) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type base_expression (* inlined *) = Token.t (* "base" *)
[@@deriving sexp_of]

type implicit_type (* inlined *) = Token.t (* "var" *)
[@@deriving sexp_of]

type extern_alias_directive (* inlined *) = (
    Token.t (* "extern" *) * Token.t (* "alias" *) * identifier (*tok*)
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type parenthesized_variable_designation (* inlined *) = (
    Token.t (* "(" *)
  * (
        variable_designation
      * (Token.t (* "," *) * variable_designation) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type string_literal (* inlined *) = (
    Token.t (* "\"" *)
  * [
        `Imm_tok_pat_5a6fa79 of imm_tok_pat_5a6fa79 (*tok*)
      | `Esc_seq of escape_sequence (*tok*)
    ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)
[@@deriving sexp_of]

type character_literal (* inlined *) = (
    Token.t (* "'" *)
  * [
        `Imm_tok_pat_684220d of imm_tok_pat_684220d (*tok*)
      | `Esc_seq of escape_sequence (*tok*)
    ]
  * Token.t (* "'" *)
)
[@@deriving sexp_of]

type var_pattern (* inlined *) = (Token.t (* "var" *) * variable_designation)
[@@deriving sexp_of]

type preprocessor_call (* inlined *) = (
    preprocessor_directive (*tok*)
  * [
        `Id of identifier (*tok*)
      | `Lit of literal
      | `Tok_pat_f6e1de8 of tok_pat_f6e1de8 (*tok*)
    ]
      list (* zero or more *)
  * preproc_directive_end (*tok*)
)
[@@deriving sexp_of]

type alias_qualified_name (* inlined *) = (
    identifier_or_global * Token.t (* "::" *) * simple_name
)
[@@deriving sexp_of]

type anonymous_method_expression (* inlined *) = (
    Token.t (* "async" *) option
  * Token.t (* "delegate" *)
  * parameter_list option
  * block
)
[@@deriving sexp_of]

type anonymous_object_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * Token.t (* "{" *)
  * (
        anonymous_object_member_declarator
      * (Token.t (* "," *) * anonymous_object_member_declarator)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type array_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * array_type
  * initializer_expression option
)
[@@deriving sexp_of]

type assignment_expression (* inlined *) = (
    constant_pattern * assignment_operator * constant_pattern
)
[@@deriving sexp_of]

type await_expression (* inlined *) = (
    Token.t (* "await" *) * constant_pattern
)
[@@deriving sexp_of]

type cast_expression (* inlined *) = (
    Token.t (* "(" *) * type_constraint * Token.t (* ")" *)
  * constant_pattern
)
[@@deriving sexp_of]

type checked_statement (* inlined *) = (
    [ `Chec of Token.t (* "checked" *) | `Unch of Token.t (* "unchecked" *) ]
  * block
)
[@@deriving sexp_of]

type conditional_access_expression (* inlined *) = (
    constant_pattern * Token.t (* "?" *) * constant_pattern
)
[@@deriving sexp_of]

type conditional_expression (* inlined *) = (
    constant_pattern * Token.t (* "?" *) * constant_pattern
  * Token.t (* ":" *) * constant_pattern
)
[@@deriving sexp_of]

type declaration_pattern (* inlined *) = (
    type_constraint * variable_designation
)
[@@deriving sexp_of]

type deep_ellipsis (* inlined *) = (
    Token.t (* "<..." *) * constant_pattern * Token.t (* "...>" *)
)
[@@deriving sexp_of]

type default_expression (* inlined *) = (
    Token.t (* "default" *)
  * (Token.t (* "(" *) * type_constraint * Token.t (* ")" *)) option
)
[@@deriving sexp_of]

type do_statement (* inlined *) = (
    Token.t (* "do" *) * statement * Token.t (* "while" *)
  * Token.t (* "(" *) * constant_pattern * Token.t (* ")" *)
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type element_access_expression (* inlined *) = (
    constant_pattern * element_binding_expression
)
[@@deriving sexp_of]

type fixed_statement (* inlined *) = (
    Token.t (* "fixed" *) * Token.t (* "(" *) * variable_declaration
  * Token.t (* ")" *) * statement
)
[@@deriving sexp_of]

type for_each_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "foreach" *)
  * Token.t (* "(" *)
  * [ `Type_id of declaration_expression | `Exp of constant_pattern ]
  * Token.t (* "in" *)
  * constant_pattern
  * Token.t (* ")" *)
  * statement
)
[@@deriving sexp_of]

type for_statement (* inlined *) = (
    Token.t (* "for" *)
  * Token.t (* "(" *)
  * [
        `Var_decl of variable_declaration
      | `Exp_rep_COMMA_exp of (
            constant_pattern
          * interpolation_alignment_clause list (* zero or more *)
        )
    ]
      option
  * Token.t (* ";" *)
  * constant_pattern option
  * Token.t (* ";" *)
  * anon_opt_cst_pat_rep_interp_alig_clause_080fdff
  * Token.t (* ")" *)
  * statement
)
[@@deriving sexp_of]

type generic_name (* inlined *) = (identifier (*tok*) * type_argument_list)
[@@deriving sexp_of]

type goto_statement (* inlined *) = (
    Token.t (* "goto" *)
  * [
        `Id of identifier (*tok*)
      | `Case_exp of (Token.t (* "case" *) * constant_pattern)
      | `Defa of Token.t (* "default" *)
    ]
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type group_clause (* inlined *) = (
    Token.t (* "group" *) * constant_pattern * Token.t (* "by" *)
  * constant_pattern
)
[@@deriving sexp_of]

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * Token.t (* "(" *)
  * constant_pattern
  * Token.t (* ")" *)
  * statement
  * (Token.t (* "else" *) * statement) option
)
[@@deriving sexp_of]

type implicit_array_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * Token.t (* "[" *)
  * Token.t (* "," *) list (* zero or more *)
  * Token.t (* "]" *)
  * initializer_expression
)
[@@deriving sexp_of]

type implicit_stack_alloc_array_creation_expression (* inlined *) = (
    Token.t (* "stackalloc" *) * Token.t (* "[" *) * Token.t (* "]" *)
  * initializer_expression
)
[@@deriving sexp_of]

type invocation_expression (* inlined *) = (constant_pattern * argument_list)
[@@deriving sexp_of]

type is_pattern_expression (* inlined *) = (
    constant_pattern * Token.t (* "is" *) * pattern
)
[@@deriving sexp_of]

type join_clause (* inlined *) = (
    Token.t (* "join" *)
  * type_constraint option
  * identifier (*tok*)
  * Token.t (* "in" *)
  * constant_pattern
  * Token.t (* "on" *)
  * constant_pattern
  * Token.t (* "equals" *)
  * constant_pattern
  * join_into_clause option
)
[@@deriving sexp_of]

type labeled_statement (* inlined *) = (
    identifier (*tok*) * Token.t (* ":" *) * statement
)
[@@deriving sexp_of]

type lambda_expression (* inlined *) = (
    Token.t (* "async" *) option
  * [ `Param_list of parameter_list | `Id of identifier (*tok*) ]
  * Token.t (* "=>" *)
  * [ `Blk of block | `Exp of constant_pattern ]
)
[@@deriving sexp_of]

type let_clause (* inlined *) = (
    Token.t (* "let" *) * identifier (*tok*) * Token.t (* "=" *)
  * constant_pattern
)
[@@deriving sexp_of]

type local_declaration_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "using" *) option
  * modifier list (* zero or more *)
  * variable_declaration
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type local_function_statement (* inlined *) = (
    modifier list (* zero or more *)
  * return_type
  * identifier (*tok*)
  * type_parameter_list option
  * parameter_list
  * type_parameter_constraints_clause list (* zero or more *)
  * function_body
)
[@@deriving sexp_of]

type lock_statement (* inlined *) = (
    Token.t (* "lock" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* ")" *) * statement
)
[@@deriving sexp_of]

type make_ref_expression (* inlined *) = (
    Token.t (* "__makeref" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type member_access_expression (* inlined *) = (
    [ `Exp of constant_pattern | `Type of type_constraint | `Name of name ]
  * [ `DOT of Token.t (* "." *) | `DASHGT of Token.t (* "->" *) ]
  * simple_name
)
[@@deriving sexp_of]

type member_binding_expression (* inlined *) = (
    Token.t (* "." *) * simple_name
)
[@@deriving sexp_of]

type object_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * type_constraint
  * argument_list option
  * initializer_expression option
)
[@@deriving sexp_of]

type order_by_clause (* inlined *) = (
    Token.t (* "orderby" *)
  * ordering
  * (Token.t (* "," *) * ordering) list (* zero or more *)
)
[@@deriving sexp_of]

type parameter_array (* inlined *) = (
    attribute_list list (* zero or more *)
  * Token.t (* "params" *)
  * array_type
  * identifier (*tok*)
)
[@@deriving sexp_of]

type parenthesized_expression (* inlined *) = (
    Token.t (* "(" *) * constant_pattern * Token.t (* ")" *)
)
[@@deriving sexp_of]

type pointer_type (* inlined *) = (type_constraint * Token.t (* "*" *))
[@@deriving sexp_of]

type qualified_name (* inlined *) = (name * Token.t (* "." *) * simple_name)
[@@deriving sexp_of]

type query_expression (* inlined *) = (from_clause * query_body)
[@@deriving sexp_of]

type range_expression (* inlined *) = (
    constant_pattern option
  * Token.t (* ".." *)
  * constant_pattern option
)
[@@deriving sexp_of]

type ref_expression (* inlined *) = (Token.t (* "ref" *) * constant_pattern)
[@@deriving sexp_of]

type ref_type_expression (* inlined *) = (
    Token.t (* "__reftype" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type ref_value_expression (* inlined *) = (
    Token.t (* "__refvalue" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* "," *) * type_constraint * Token.t (* ")" *)
)
[@@deriving sexp_of]

type return_statement (* inlined *) = (
    Token.t (* "return" *)
  * constant_pattern option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type select_clause (* inlined *) = (
    Token.t (* "select" *) * constant_pattern
)
[@@deriving sexp_of]

type size_of_expression (* inlined *) = (
    Token.t (* "sizeof" *) * Token.t (* "(" *) * type_constraint
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type stack_alloc_array_creation_expression (* inlined *) = (
    Token.t (* "stackalloc" *)
  * array_type
  * initializer_expression option
)
[@@deriving sexp_of]

type switch_expression (* inlined *) = (
    constant_pattern
  * Token.t (* "switch" *)
  * Token.t (* "{" *)
  * (
        switch_expression_arm
      * (Token.t (* "," *) * switch_expression_arm) list (* zero or more *)
    )
      option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type switch_statement (* inlined *) = (
    Token.t (* "switch" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* ")" *) * switch_body
)
[@@deriving sexp_of]

type throw_expression (* inlined *) = (
    Token.t (* "throw" *) * constant_pattern
)
[@@deriving sexp_of]

type throw_statement (* inlined *) = (
    Token.t (* "throw" *)
  * constant_pattern option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type try_statement (* inlined *) = (
    Token.t (* "try" *)
  * block
  * catch_clause list (* zero or more *)
  * finally_clause option
)
[@@deriving sexp_of]

type tuple_expression (* inlined *) = (
    Token.t (* "(" *)
  * argument
  * (Token.t (* "," *) * argument) list (* one or more *)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type tuple_type (* inlined *) = (
    Token.t (* "(" *)
  * tuple_element
  * (Token.t (* "," *) * tuple_element) list (* one or more *)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type type_of_expression (* inlined *) = (
    Token.t (* "typeof" *) * Token.t (* "(" *) * type_constraint
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type unsafe_statement (* inlined *) = (Token.t (* "unsafe" *) * block)
[@@deriving sexp_of]

type using_statement (* inlined *) = (
    Token.t (* "await" *) option
  * Token.t (* "using" *)
  * Token.t (* "(" *)
  * [ `Var_decl of variable_declaration | `Exp of constant_pattern ]
  * Token.t (* ")" *)
  * statement
)
[@@deriving sexp_of]

type where_clause (* inlined *) = (Token.t (* "where" *) * constant_pattern)
[@@deriving sexp_of]

type while_statement (* inlined *) = (
    Token.t (* "while" *) * Token.t (* "(" *) * constant_pattern
  * Token.t (* ")" *) * statement
)
[@@deriving sexp_of]

type yield_statement (* inlined *) = (
    Token.t (* "yield" *)
  * [
        `Ret_exp of (Token.t (* "return" *) * constant_pattern)
      | `Brk of Token.t (* "break" *)
    ]
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type event_field_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "event" *)
  * variable_declaration
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type operator_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_constraint
  * Token.t (* "operator" *)
  * overloadable_operator
  * parameter_list
  * function_body
)
[@@deriving sexp_of]

type using_directive (* inlined *) = (
    Token.t (* "using" *)
  * [ `Static of Token.t (* "static" *) | `Name_equals of name_equals ]
      option
  * name
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type ref_type (* inlined *) = (
    Token.t (* "ref" *)
  * Token.t (* "readonly" *) option
  * type_constraint
)
[@@deriving sexp_of]

type delegate_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "delegate" *)
  * return_type
  * identifier (*tok*)
  * type_parameter_list option
  * parameter_list
  * type_parameter_constraints_clause list (* zero or more *)
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type destructor_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * Token.t (* "extern" *) option
  * Token.t (* "~" *)
  * identifier (*tok*)
  * parameter_list
  * function_body
)
[@@deriving sexp_of]

type semgrep_expression (* inlined *) = (
    Token.t (* "__SEMGREP_EXPRESSION" *) * constant_pattern
)
[@@deriving sexp_of]

type global_attribute_list (* inlined *) = (
    Token.t (* "[" *)
  * [ `Asse of Token.t (* "assembly" *) | `Module of Token.t (* "module" *) ]
  * Token.t (* ":" *)
  * (attribute * (Token.t (* "," *) * attribute) list (* zero or more *))
      option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type field_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * variable_declaration
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type conversion_operator_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * [ `Impl of Token.t (* "implicit" *) | `Expl of Token.t (* "explicit" *) ]
  * Token.t (* "operator" *)
  * type_constraint
  * parameter_list
  * function_body
)
[@@deriving sexp_of]

type constructor_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * identifier (*tok*)
  * parameter_list
  * constructor_initializer option
  * function_body
)
[@@deriving sexp_of]

type method_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * return_type
  * explicit_interface_specifier option
  * identifier (*tok*)
  * type_parameter_list option
  * parameter_list
  * type_parameter_constraints_clause list (* zero or more *)
  * function_body
)
[@@deriving sexp_of]

type enum_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "enum" *)
  * identifier (*tok*)
  * base_list option
  * enum_member_declaration_list
  * Token.t (* ";" *) option
)
[@@deriving sexp_of]

type property_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_constraint
  * explicit_interface_specifier option
  * identifier (*tok*)
  * [
        `Acce_list_opt_EQ_exp_SEMI of (
            accessor_list
          * (Token.t (* "=" *) * constant_pattern * Token.t (* ";" *)) option
        )
      | `Arrow_exp_clause_SEMI of (
            arrow_expression_clause * Token.t (* ";" *)
        )
    ]
)
[@@deriving sexp_of]

type event_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "event" *)
  * type_constraint
  * explicit_interface_specifier option
  * identifier (*tok*)
  * [ `Acce_list of accessor_list | `SEMI of Token.t (* ";" *) ]
)
[@@deriving sexp_of]

type indexer_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * type_constraint
  * explicit_interface_specifier option
  * Token.t (* "this" *)
  * bracketed_parameter_list
  * [
        `Acce_list of accessor_list
      | `Arrow_exp_clause_SEMI of (
            arrow_expression_clause * Token.t (* ";" *)
        )
    ]
)
[@@deriving sexp_of]

type recursive_pattern (* inlined *) = (
    type_constraint option
  * positional_pattern_clause option
  * property_pattern_clause option
  * variable_designation option
)
[@@deriving sexp_of]

type class_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "class" *)
  * identifier (*tok*)
  * type_parameter_list option
  * base_list option
  * type_parameter_constraints_clause list (* zero or more *)
  * declaration_list
  * Token.t (* ";" *) option
)
[@@deriving sexp_of]

type interface_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "interface" *)
  * identifier (*tok*)
  * type_parameter_list option
  * base_list option
  * type_parameter_constraints_clause list (* zero or more *)
  * declaration_list
  * Token.t (* ";" *) option
)
[@@deriving sexp_of]

type namespace_declaration (* inlined *) = (
    Token.t (* "namespace" *)
  * name
  * declaration_list
  * Token.t (* ";" *) option
)
[@@deriving sexp_of]

type struct_declaration (* inlined *) = (
    attribute_list list (* zero or more *)
  * modifier list (* zero or more *)
  * Token.t (* "struct" *)
  * identifier (*tok*)
  * type_parameter_list option
  * base_list option
  * type_parameter_constraints_clause list (* zero or more *)
  * declaration_list
  * Token.t (* ";" *) option
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_compilation_unit root
  |> Print_sexp.to_stdout
